import { Command } from 'commander'
import { readFile, writeFile, chmod, access, mkdir, unlink } from 'fs/promises'
import { join } from 'path'
import { constants } from 'fs'

// POSIX-compatible hook content marker
const GEV_MARKER_START = '# >>> gev:managed (do not edit this block)'
const GEV_MARKER_END = '# <<< gev:managed (end)'

// Hook script template - POSIX compatible
const generateHookContent = (hookType: 'pre-push' | 'pre-commit'): string => {
  return `#!/bin/sh
${GEV_MARKER_START}
# gev ${hookType} hook - auto-generated by envvault
# Run 'envvault hooks uninstall --type ${hookType}' to remove
npx gev verify || { echo "gev verify failed. ${hookType} aborted."; exit 1; }
${GEV_MARKER_END}
`
}

/**
 * Find the .git directory path
 */
async function findGitDirectory(cwd: string): Promise<string | null> {
  try {
    // Check for .git in current directory
    const gitPath = join(cwd, '.git')
    await access(gitPath, constants.F_OK)
    return gitPath
  } catch {
    return null
  }
}

/**
 * Check if a hook file contains gev managed content
 */
async function hasGevHookContent(hookPath: string): Promise<boolean> {
  try {
    const content = await readFile(hookPath, 'utf-8')
    return content.includes(GEV_MARKER_START) && content.includes(GEV_MARKER_END)
  } catch {
    return false
  }
}

/**
 * Extract non-gev content from a hook file
 */
async function extractNonGevContent(hookPath: string): Promise<string> {
  try {
    const content = await readFile(hookPath, 'utf-8')
    
    // Check if it's only gev content
    if (!content.includes(GEV_MARKER_START)) {
      return content
    }
    
    // Remove gev block
    const lines = content.split('\n')
    const result: string[] = []
    let inGevBlock = false
    
    for (const line of lines) {
      if (line.includes(GEV_MARKER_START)) {
        inGevBlock = true
        continue
      }
      if (line.includes(GEV_MARKER_END)) {
        inGevBlock = false
        continue
      }
      if (!inGevBlock) {
        result.push(line)
      }
    }
    
    // Filter out empty lines at start/end and join
    return result.join('\n').trim()
  } catch {
    return ''
  }
}

/**
 * Install a git hook
 */
export async function installHook(options: {
  type: 'pre-push' | 'pre-commit'
  cwd?: string
}): Promise<{ success: boolean; message: string; path?: string }> {
  const cwd = options.cwd ?? process.cwd()
  const gitDir = await findGitDirectory(cwd)
  
  if (!gitDir) {
    return {
      success: false,
      message: 'Not a git repository (or any of the parent directories): .git'
    }
  }
  
  const hooksDir = join(gitDir, 'hooks')
  const hookPath = join(hooksDir, options.type.replace('-', '-'))
  
  // Normalize hook filename (pre-push stays pre-push, pre-commit stays pre-commit)
  const normalizedHookPath = join(hooksDir, options.type)
  
  try {
    // Ensure hooks directory exists
    await mkdir(hooksDir, { recursive: true })
    
    // Check if already has gev content
    if (await hasGevHookContent(normalizedHookPath)) {
      return {
        success: true,
        message: `${options.type} hook already contains gev managed content`,
        path: normalizedHookPath
      }
    }
    
    // Get existing content
    const existingContent = await extractNonGevContent(normalizedHookPath)
    
    // Generate new hook content
    const gevContent = generateHookContent(options.type)
    
    // Combine content: existing content first, then gev block
    let newContent: string
    if (existingContent.trim()) {
      // Preserve existing content but ensure shebang
      let content = existingContent
      if (!content.startsWith('#!/')) {
        content = `#!/bin/sh\n${content}`
      }
      newContent = `${content}\n\n${gevContent}`
    } else {
      newContent = gevContent
    }
    
    // Write the hook file
    await writeFile(normalizedHookPath, newContent, 'utf-8')
    
    // Make executable (0o755 = rwxr-xr-x)
    await chmod(normalizedHookPath, 0o755)
    
    return {
      success: true,
      message: `Successfully installed ${options.type} hook`,
      path: normalizedHookPath
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return {
      success: false,
      message: `Failed to install ${options.type} hook: ${errorMessage}`
    }
  }
}

/**
 * Uninstall a git hook (remove gev managed portion)
 */
export async function uninstallHook(options: {
  type: 'pre-push' | 'pre-commit'
  cwd?: string
}): Promise<{ success: boolean; message: string }> {
  const cwd = options.cwd ?? process.cwd()
  const gitDir = await findGitDirectory(cwd)
  
  if (!gitDir) {
    return {
      success: false,
      message: 'Not a git repository'
    }
  }
  
  const hookPath = join(gitDir, 'hooks', options.type)
  
  try {
    // Check if hook exists and has gev content
    const hasGev = await hasGevHookContent(hookPath)
    
    if (!hasGev) {
      return {
        success: false,
        message: `${options.type} hook does not contain gev managed content`
      }
    }
    
    // Extract non-gev content
    const remainingContent = await extractNonGevContent(hookPath)
    
    if (remainingContent.trim()) {
      // Write back without gev content
      await writeFile(hookPath, remainingContent + '\n', 'utf-8')
      return {
        success: true,
        message: `Removed gev content from ${options.type} hook (preserved existing hook logic)`
      }
    } else {
      // Remove the file entirely if it was only gev content
      await unlink(hookPath)
      return {
        success: true,
        message: `Removed ${options.type} hook`
      }
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return {
      success: false,
      message: `Failed to uninstall ${options.type} hook: ${errorMessage}`
    }
  }
}

/**
 * Check status of git hooks
 */
export async function checkHooksStatus(options?: {
  cwd?: string
}): Promise<{
  prePush: boolean
  preCommit: boolean
  prePushPath?: string
  preCommitPath?: string
}> {
  const cwd = options?.cwd ?? process.cwd()
  const gitDir = await findGitDirectory(cwd)
  
  const result = {
    prePush: false,
    preCommit: false,
    prePushPath: undefined as string | undefined,
    preCommitPath: undefined as string | undefined
  }
  
  if (!gitDir) {
    return result
  }
  
  const hooksDir = join(gitDir, 'hooks')
  
  // Check pre-push
  const prePushPath = join(hooksDir, 'pre-push')
  result.prePush = await hasGevHookContent(prePushPath)
  if (result.prePush) {
    result.prePushPath = prePushPath
  }
  
  // Check pre-commit
  const preCommitPath = join(hooksDir, 'pre-commit')
  result.preCommit = await hasGevHookContent(preCommitPath)
  if (result.preCommit) {
    result.preCommitPath = preCommitPath
  }
  
  return result
}

// CLI Commands
const hooksCommand = new Command('hooks')
  .description('Manage git hooks for environment verification')

// Install subcommand
hooksCommand
  .command('install')
  .description('Install git hooks for environment verification')
  .option('--type <type>', 'Hook type (pre-push or pre-commit)', 'pre-push')
  .action(async (options) => {
    const hookType = options.type as 'pre-push' | 'pre-commit'
    
    if (hookType !== 'pre-push' && hookType !== 'pre-commit') {
      console.error('‚ùå Invalid hook type. Use "pre-push" or "pre-commit"')
      process.exit(1)
    }
    
    console.log(`üîß Installing ${hookType} hook...`)
    
    const result = await installHook({ type: hookType })
    
    if (result.success) {
      console.log(`‚úÖ ${result.message}`)
      if (result.path) {
        console.log(`   Path: ${result.path}`)
      }
    } else {
      console.error(`‚ùå ${result.message}`)
      process.exit(1)
    }
  })

// Uninstall subcommand
hooksCommand
  .command('uninstall')
  .description('Uninstall git hooks')
  .option('--type <type>', 'Hook type (pre-push or pre-commit)', 'pre-push')
  .action(async (options) => {
    const hookType = options.type as 'pre-push' | 'pre-commit'
    
    if (hookType !== 'pre-push' && hookType !== 'pre-commit') {
      console.error('‚ùå Invalid hook type. Use "pre-push" or "pre-commit"')
      process.exit(1)
    }
    
    console.log(`üóëÔ∏è Uninstalling ${hookType} hook...`)
    
    const result = await uninstallHook({ type: hookType })
    
    if (result.success) {
      console.log(`‚úÖ ${result.message}`)
    } else {
      console.error(`‚ùå ${result.message}`)
      process.exit(1)
    }
  })

// Status subcommand
hooksCommand
  .command('status')
  .description('Show status of installed git hooks')
  .action(async () => {
    console.log('üìã Git Hooks Status\n')
    
    const status = await checkHooksStatus()
    
    const prePushIcon = status.prePush ? '‚úÖ' : '‚ùå'
    const preCommitIcon = status.preCommit ? '‚úÖ' : '‚ùå'
    
    console.log(`  ${prePushIcon} pre-push:   ${status.prePush ? 'Installed' : 'Not installed'}${status.prePushPath ? ` (${status.prePushPath})` : ''}`)
    console.log(`  ${preCommitIcon} pre-commit: ${status.preCommit ? 'Installed' : 'Not installed'}${status.preCommitPath ? ` (${status.preCommitPath})` : ''}`)
    
    if (!status.prePush && !status.preCommit) {
      console.log('\nüí° Run "envvault hooks install" to install hooks')
    }
  })

export { hooksCommand }
export default hooksCommand
